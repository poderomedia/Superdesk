define(['gizmo/superdesk'], function(Gizmo) {	return Gizmo.Collection.extend({		timeInterval: 10000,		idInterval: 0,		_latestCId: 0,		/*!		 * for auto refresh		 */		keep: false,		init: function(){ 			var self = this;			this.on('readauto updatesauto read updates addings addingsauto',function(evt, data)			{				if(data === undefined)					data = self._list;				self.getMaximumCid(data);			});		},		destroy: function(){ this.stop(); },		auto: function(fn)		{			var self = this;			ret = this.stop().start();			this.idInterval = setInterval(function(){self.start();}, this.timeInterval);			return ret;		},		getMaximumCid: function(data)		{			for(i=0, count=data.length; i<count; i++) {									var CId = parseInt(data[i].get('CId'))				if( !isNaN(CId) && (this._latestCId < CId) )					this._latestCId = CId;			}		},		start: function()		{			var self = this, requestOptions = {data: {'cId.since': this._latestCId}, headers: { 'X-Filter': self._xfilter, 'X-Format-DateTime': 'M/dd/yyyy HH:mm:ss'}}; 			if(self._latestCId === 0) delete requestOptions.data;			if(!this.keep && self.view && !self.view.checkElement()) 			{				self.stop();				return;			}							this.triggerHandler('beforeUpdate');			return this.autosync(requestOptions);		},		stop: function()		{			var self = this;			clearInterval(self.idInterval);			return this;		},		autosync: function()		{		var self = this;		return (this.href &&			this.syncAdapter.request.call(this.syncAdapter, this.href).read(arguments[0]).done(function(data)			{				var data = self._parse(data), addings = [], updates = [], count = self._list.length;				 // important or it will infiloop				for( var i=0; i < data.length; i++ )				{					var model = false;					for( var j=0; j<count; j++ ) {						if( data[i].hash() == self._list[j].hash() )						{							model = data[i];							break;						}					}					if( !model ) {						if( !data[i].isDeleted() ) {							self._list.push(data[i]);							addings.push(data[i]);						} else {							updates.push(data[i]);												}					}					else {						updates.push(model);						if( model.isDeleted() ) {							model._remove();						} else {							model.on('delete', function(){self.remove(this.hash());})									.on('garbage', function(){this.desynced = true;});						}					}				}				self.desynced = false;				/**				 * If the initial data is empty then trigger READ event				 * else UPDATE with the changeset if there are some				 */				if( ( count === 0) ){					//console.log('read');					self.triggerHandler('readauto');				} else {                    					/**					 * Trigger handler with changeset extraparameter as a vector of vectors,					 * caz jquery will send extraparameters as arguments when calling handler					 */					//console.log('update');					self.triggerHandler('updatesauto', [updates]);					self.triggerHandler('addingsauto', [addings]);				}			}));		}		},{ register: 'AutoCollection' });});